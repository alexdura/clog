import java.util.ArrayList;
import clang.ASTMatcher;
import clang.AST;

aspect CDecl {
	///
	syn java.util.List<ConcreteDeclaration> Declaration.decls() {
		java.util.List<ConcreteDeclaration> ret = new ArrayList<>();

		for (InitDeclarator id : this.getInitDeclarators()) {
			Declarator d = id.getDeclarator();

			ret.add(new ConcreteDeclaration(this.getDeclarationSpecifiers().treeCopy(), d.treeCopy()));
		}

		return ret;
	}

	///
	syn Identifier ConcreteDeclaration.declaredIdentifier() = getDeclarator().declaredIdentifier();
	syn Identifier Declarator.declaredIdentifier() { throw new RuntimeException("Declarator.declaredIdentifier() not implemented."); }

	eq IdentifierDeclarator.declaredIdentifier() = getIdentifier();
	eq PointerDeclarator.declaredIdentifier() = getDeclarator().declaredIdentifier();
	eq ArrayDeclarator.declaredIdentifier() = getDeclarator().declaredIdentifier();
	eq ArrayDeclaratorVLA.declaredIdentifier() = getDeclarator().declaredIdentifier();
	eq FunctionDeclarator.declaredIdentifier() = getDeclarator().declaredIdentifier();

	// Extract a type from a declaration.
	static AST.Type DeclarationSpecifier.typeFromDeclarationSpecifiers(Iterable<DeclarationSpecifier> specs) {
		java.util.List<AST.BuiltinTypeKind> typeKinds = new ArrayList<>();
		java.util.List<AST.TypeQualifier> typeQuals = new ArrayList<>();
		AST.StorageClass storage = null;

		for (DeclarationSpecifier ds : specs) {
			AST.BuiltinTypeKind type = ds.asBuiltinTypeKind();
			if (type != null)
				typeKinds.add(type);

			AST.TypeQualifier typeQual = ds.asTypeQualifier();
			if (typeQual != null)
				typeQuals.add(typeQual);

			AST.StorageClass sc = ds.asStorageClass();
			if (sc != null) {
				if (storage != null) {
					throw new RuntimeException("At most one storage class for a declaration!");
				}
				storage = sc;
			}
		}

		if (typeKinds.isEmpty()) {
			// TODO: this may be a reference to a typedefed type,
			// or a record/enum definition
			return null;
		} else {
			AST.BuiltinType t = AST.BuiltinType.build(typeKinds);
			t.setTypeQuals(typeQuals);
			if (storage != null) {
				// Explicit storage class found. Set it.
				t.setStorage(storage);
			}
			return t;
		}
	}

	syn java.util.List<clang.AST.Decl> Declaration.clangDecls() {
		java.util.List<clang.AST.Decl> ret = new ArrayList<>();
		AST.Type innerType = DeclarationSpecifier.typeFromDeclarationSpecifiers(getDeclarationSpecifiers());

		for (InitDeclarator initDecl : getInitDeclarators()) {
			ret.add(initDecl.getDeclarator().asClangDecl(innerType));
		}

		return ret;
	}

	syn AST.Decl Declarator.asClangDecl(AST.Type innerType) {
		Identifier ident = this.declaredIdentifier();
		AST.Type type = this.asType(innerType);
		return AST.VarDecl.build(ident.getID(), type);
	}

	eq FunctionDeclarator.asClangDecl(AST.Type innerType) {
		Identifier ident = this.declaredIdentifier();
		AST.Type type = this.asType(innerType);

		java.util.List<AST.ParmVarDecl> params = new ArrayList<>();
		for (ParameterType pt : getParameterTypes()) {
			params.add(pt.asClangDecl());
		}

		return AST.FunctionDecl.build(ident.getID(), type, params);
	}

	syn AST.ParmVarDecl ParameterType.asClangDecl() { throw new RuntimeException("ParameterType.asClangDecl() not implemented."); }
	eq ParameterDeclaration.asClangDecl() {
		Identifier ident = this.getDeclarator().declaredIdentifier();
		AST.Type type = this.asType();
		return AST.ParmVarDecl.build(ident.getID(), type);
	}

	eq AbstractParameterDeclaration.asClangDecl() {
		AST.Type type = this.asType();
		return AST.ParmVarDecl.build(type);
	}


	syn AST.Type ParameterType.asType() { throw new RuntimeException("ParameterType.asType() not implemented."); }
	eq ParameterDeclaration.asType() {
		AST.Type innerType = DeclarationSpecifier.typeFromDeclarationSpecifiers(getDeclarationSpecifiers());
		return getDeclarator().asType(innerType);
	}

	eq AbstractParameterDeclaration.asType() {
		AST.Type innerType = DeclarationSpecifier.typeFromDeclarationSpecifiers(getDeclarationSpecifiers());
		if (hasAbstractDeclarator()) {
			return getAbstractDeclarator().asType(innerType);
		} else {
			return innerType;
		}
	}

	syn AST.Type Declarator.asType(AST.Type innerType);
	eq IdentifierDeclarator.asType(AST.Type innerType) = innerType;
	eq PointerDeclarator.asType(AST.Type innerType) {
		AST.Type t = AST.PointerType.build(getDeclarator().asType(innerType));
		for (TypeQualifier q : getTypeQualifiers()) {
			t.addQual(q.asTypeQualifier());
		}
		return t;
	}

	eq ArrayDeclarator.asType(AST.Type innerType) {
		AST.Type t = AST.ArrayType.build(getDeclarator().asType(innerType));
		for (TypeQualifier q : getTypeQualifiers()) {
			t.addQual(q.asTypeQualifier());
		}
		return t;
	}

	eq ArrayDeclaratorVLA.asType(AST.Type innerType) {
		AST.Type t = AST.ArrayType.build(getDeclarator().asType(innerType));
		for (TypeQualifier q : getTypeQualifiers()) {
			t.addQual(q.asTypeQualifier());
		}
		return t;
	}

	eq FunctionDeclarator.asType(AST.Type innerType) {
		java.util.List<AST.Type> paramTypes = new ArrayList<>();
		for (ParameterType pDecl : getParameterTypes()) {
			paramTypes.add(pDecl.asType());
		}
		return AST.FunctionProtoType.build(getDeclarator().asType(innerType) , paramTypes);
	}


	syn AST.Type AbstractDeclarator.asType(AST.Type innerType) { throw new
			RuntimeException(Thread.currentThread().getStackTrace()[0].getMethodName() + " not implemented.");
	}

	eq AbstractPointerDeclarator.asType(AST.Type innerType) {
		AST.Type t;
		if (hasAbstractDeclarator()) {
			t = AST.PointerType.build(getAbstractDeclarator().asType(innerType));
		} else {
			t = AST.PointerType.build(innerType);
		}

		for (TypeQualifier q : getTypeQualifiers()) {
			t.addQual(q.asTypeQualifier());
		}
		return t;
	}

	eq AbstractArrayDeclarator.asType(AST.Type innerType) {
		AST.Type t;
		if (hasAbstractDeclarator()) {
			t = AST.ArrayType.build(getAbstractDeclarator().asType(innerType));
		} else {
			t = AST.ArrayType.build(innerType);
		}

		for (TypeQualifier q : getTypeQualifiers()) {
			t.addQual(q.asTypeQualifier());
		}
		return t;
	}

	eq AbstractArrayDeclaratorVLA.asType(AST.Type innerType) {
		AST.Type t;
		if (hasAbstractDeclarator()) {
			t = AST.ArrayType.build(getAbstractDeclarator().asType(innerType));
		} else {
			t = AST.ArrayType.build(innerType);
		}

		for (TypeQualifier q : getTypeQualifiers()) {
			t.addQual(q.asTypeQualifier());
		}
		return t;
	}

	eq AbstractFunctionDeclarator.asType(AST.Type innerType) {
		AST.Type t;
		if (hasAbstractDeclarator()) {
			t = AST.ArrayType.build(getAbstractDeclarator().asType(innerType));
		} else {
			t = innerType;
		}


		java.util.List<AST.Type> paramTypes = new ArrayList<>();
		for (ParameterType pDecl : getParameterTypes()) {
			paramTypes.add(pDecl.asType());
		}

		return AST.FunctionProtoType.build(t, paramTypes);
	}

	eq MetaVarDeclarator.asType(AST.Type innerType) { throw new RuntimeException("MetaVarDeclarator.asType() should never be called."); }
	eq GapDeclarator.asType(AST.Type innerType) { throw new RuntimeException("GapDeclarator.asType() should never be called."); }
	eq IndexMetaVarDeclarator.asType(AST.Type innerType) { throw new RuntimeException("IndexMetaVarDeclarator.asType() should never be called."); }

	syn AST.BuiltinTypeKind DeclarationSpecifier.asBuiltinTypeKind() = null;
	eq Void.asBuiltinTypeKind() = AST.BuiltinTypeKind.VOID;
	eq Char.asBuiltinTypeKind() = AST.BuiltinTypeKind.CHAR;
	eq Short.asBuiltinTypeKind() = AST.BuiltinTypeKind.SHORT;
	eq Int.asBuiltinTypeKind() = AST.BuiltinTypeKind.INT;
	eq Long.asBuiltinTypeKind() = AST.BuiltinTypeKind.LONG;
	eq Float.asBuiltinTypeKind() = AST.BuiltinTypeKind.FLOAT;
	eq Double.asBuiltinTypeKind() = AST.BuiltinTypeKind.DOUBLE;
	eq Signed.asBuiltinTypeKind() = AST.BuiltinTypeKind.SIGNED;
	eq Unsigned.asBuiltinTypeKind() = AST.BuiltinTypeKind.UNSIGNED;
	eq Bool.asBuiltinTypeKind() = AST.BuiltinTypeKind.BOOL;
	eq Complex.asBuiltinTypeKind() = AST.BuiltinTypeKind.COMPLEX;

	syn AST.StorageClass DeclarationSpecifier.asStorageClass() = null;
	eq Extern.asStorageClass() = AST.StorageClass.EXTERN;
	eq Static.asStorageClass() = AST.StorageClass.STATIC;
	eq ThreadLocal.asStorageClass() = AST.StorageClass.THREAD_LOCAL;
	eq Auto.asStorageClass() = AST.StorageClass.AUTO;
	eq Register.asStorageClass() = AST.StorageClass.REGISTER;

	syn AST.TypeQualifier DeclarationSpecifier.asTypeQualifier() = null;
	eq Const.asTypeQualifier() = AST.TypeQualifier.CONST;
	eq Restrict.asTypeQualifier() = AST.TypeQualifier.RESTRICT;
	eq Volatile.asTypeQualifier() = AST.TypeQualifier.VOLATILE;
	eq Atomic.asTypeQualifier() = AST.TypeQualifier.ATOMIC;
}
