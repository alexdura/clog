#+TITLE: MetaDL: Datalog analyzing Datalog, C, Java or any language of your choice

MetaDL is a Datalog language extension that enables analysis of Datalog and Java
programs inside Datalog. In addition, the subset of the metalanguage that depends on the analyzed language is mechanically generated from a description of the abstract and concrete grammars of the analyzed language.

#+BEGIN_SRC prolog
Srcs("p/t0.mdl").

Arity(pname, arity) :- <: ... :- ..., $p(...,$i:$x), ... .:>, arity = $i+1, ID($p, pname).
Arity(pname, arity) :- <: ... :- ..., NOT($p(...,$i:$x)), ... .:>, arity = $i+1, ID($p, pname).
Arity(pname, arity) :- <: ..., $p(...,$i:$x), ... :- ... .:>, arity = $i+1, ID($p, pname).


OUTPUT('Arity, "Arity.csv", "csv").
#+END_SRC

* Building
MetaDL depends on modified versions of [[http://jastadd.org/web/][JastAdd]] and [[https://bitbucket.org/jastadd/jastaddparser/][JastAddParser]]. These dependencies are packaged as submodules, so run ~git submodule update --init --recursive~ to fetch them.

Ensure that the ~souffle~ executable is available in your ~$PATH~.

For the ~hybrid~ and ~incremental~ evaluation modes, a version a modified version of Souffle is needed. This version exposes an extended JNI interface and uses a different format for SQLite input and output.
#+BEGIN_SRC
git clone https://github.com/alexdura/souffle.git -b javadl
#+END_SRC
When building, make sure to enable 64-bit domains and SWIG (needed only for the hybrid mode):
#+BEGIN_SRC
./bootstrap
./configure --enable-swig --enable-64bit-domain
make
#+END_SRC

** C support
For analyzing C, MetaDL uses the Clang front-end for pattern matching. We have built a Clang library to interface with MetaDL. Run  the following commands to fetch and build a modified version of the LLVM repository:
#+BEGIN_SRC
git clone git@github.com:alexdura/llvm-project.git -b clog
#+END_SRC
To build the library, run the following commands:
#+BEGIN_SRC
cd llvm-project/build-release
cmake -G Ninja -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra"  -DBUILD_SHARED_LIBS=ON  -DLLVM_APPEND_VC_REV=OFF   ../llvm
ninja
#+END_SRC

** Java support
For analyzing Java, MetaDL needs access to a Java 8 runtime library. Set ~METADL_JAVA_RT=/path/to/jre/lib/rt.jr~ in your environment to let MetaDL know where to find this library.
Run ~./gradlew :jar~ to build MetaDL and  ~./gradlew :test~ to test it. For the tests to run, you need the ~souffle~ executable in your executable path.

** Docker
We provide a Docker image which contains MetaDL and evaluation scripts, packaged together with all the required dependencies.
#+BEGIN_SRC
cd docker
./build.sh
#+END_SRC
then run the image using:
#+BEGIN_SRC
docker run -it clog23:cc24
#+END_SRC

* Running
MetaDL supports multiple running modes, which represent a trade-off between speed and external dependencies.
** Internal evaluation
Uses the internal semi-naive evaluator and it is reasonably fast when the number of tuples is small (< 1 million).
#+BEGIN_SRC
java -jar compiler.jar --eval metadl program.mdl -F fact_dir -D output_dir
#+END_SRC
** Internal parallel evaluation
Depending on the shape of the strata dependency is graph, the parallel evaluator may speed things up.
#+BEGIN_SRC
java -jar compiler.jar --eval metadl-par program.mdl -F fact_dir -D output_dir
#+END_SRC
** Hybrid MetaDL-Souffle evaluation
This is performed in two-steps:
*** The MetaDL program is compiled to a native library.
#+BEGIN_SRC
java -jar compiler.jar --gen-hybrid program.mdl
#+END_SRC
This will generate a library called ~libSwigInterface.so~ in your current directory.
*** Running the compiled program
#+BEGIN_SRC
java -jar compiler.jar --eval hybrid program.mdl --lib /ABS/PATH/TO/libSwigInterface.so -F fact_dir -D output_dir
#+END_SRC
** Incremental evaluation
For incremental evaluation mode, the source predicate reference for an analyze block, e.g. ~Srcs~ in ~java ('Srcs) { .. }~ must contain tuples of the form ~(FilePath, MDA)~ where MDA is one of "M", "D", "A" and indicates whether the file was added, modified or removed.
*** Initial run
The initial run generates the analysis programs and initializes the cache structure.
For initial runs, the MDA component of the source predicate is always interpreted as "A".
#+BEGIN_SRC
java -jar compiler.jar --incremental init -D output_and_cache_dir -F fact_dir
#+END_SRC
*** Update run
The update run, recomputes the analysis results based on the information in the source relations. Results for files that were previously analyzed, but are not present in the source relation, are kept in the cache and updated if necessary.
#+BEGIN_SRC
java -jar compiler.jar --incremental update -D output_and_cache_dir -F fact_dir
#+END_SRC
The fact that the output and the cache share the same directory is an artifact of the current command line interface and they will be separated in the future.
** Souffle evaluation (deprecated)
When the number of tuples is becoming large, using a high performance evaluator will make the runs faster. For this, MetaDL can generate a Souffle program and then evaluate it:
#+BEGIN_SRC
java -jar compiler.jar --eval souffle program.mdl -F fact_dir -D output_dir
#+END_SRC

* Language description
** Datalog
[[https://en.wikipedia.org/wiki/Datalog][Datalog]] is a declarative query language, with roots in logic programming. Relations between tables are expressed as Horn clauses. MetaDL extends Datalog with syntactic patterns and associates side-effects to the following predicates ~EDB~ and ~OUTPUT~. The order of evaluation is as follows:
1. All predicates the ~EDB~ predicate depends upon are evaluated. For all tuples ~('P, "file")~ in the the ~EDB~ relation, the file is read as a CSV and its tuples are added to the relation ~P~.
2. Fixpoint evaluation.
3. For all values ~('P)~ in the ~OUTPUT~ relation, the contents of relation ~P~ are written out to a file ~P.csv~.

Additional Supported features:
- Stratified negation ~!P(x1,...,xn)~
- Filtering ~expr1 < expr2~, ~expr1 > expr2~
- Object creation ~v = expr~ binds a variable to the result of an expression
- Arithmetic expressions ( ~+~, ~-~, ~*~, ~/~) and string concatenation (~cat~)
- Monomorphic type inference

** Metalanguage description
*** Syntactic patterns
Datalog: ~<:$p(x, 1) :- ..., $q(..., $i:$v, ...) , ... .:>~ or Java ~<: class `c implements .., `i, .. { .. } :>~

Patterns are a mechanism to match rules and bind metavariables to terms, expressions and predicate symbols.
*** Bounded patterns
The root node of a pattern can be accessed by using a bounded pattern ~$p <:$x + $y:>~.

** Gaps
Datalog ~...~ and C or Java ~..~

Gaps express missing elements inside a list.

*** Metavariables
Datalog:  ~$x~, ~$p~  or Java: ~`c, `i~

Variables used inside analyze blocks to connect patterns with other literals in the rule
- Terms: ~p($x, $y)~
- Predicates: ~$p(x, y)~
- Arithmetic expressions: ~$x + $y~
- Index metavariables ~p(..., $i:$v, ...)~

*** Special metapredicates (Datalog and Java only)
- ~STR(c, "value")~, ~INT($c, value)~ - relate constants to their value
- ~ID(v, "name")~ - relate identifiers to their name
- ~SRC(n, l, c)~ - relate an AST node to its source location

** Examples
*** Constant folding for Datalog
#+BEGIN_SRC
#Import a program that contains BIND(t, x*y + ((1 + 2*3) - 1) / 2)



Expr($p, 0, $q, "+"), Expr($p, 1, $r, "+") :- $p <:$q + $r:>.
Expr($p, 0, $q, "*"), Expr($p, 1, $r, "*") :- $p <:$q * $r:>.
Expr($p, 0, $q, "-"), Expr($p, 1, $r, "-") :- $p <:$q - $r:>.
Expr($p, 0, $q, "/"), Expr($p, 1, $r, "/") :- $p <:$q / $r:>.

Eval(e, v) :- INT(e, v).
Eval(e, v) :- Expr(e, 0, l, "+"), Expr(e, 1, r, "+"), Eval(l, lv), Eval(r, rv), BIND(v, lv + rv).
Eval(e, v) :- Expr(e, 0, l, "*"), Expr(e, 1, r, "*"), Eval(l, lv), Eval(r, rv), BIND(v, lv * rv).
Eval(e, v) :- Expr(e, 0, l, "-"), Expr(e, 1, r, "-"), Eval(l, lv), Eval(r, rv), BIND(v, lv - rv).
Eval(e, v) :- Expr(e, 0, l, "/"), Expr(e, 1, r, "/"), Eval(l, lv), Eval(r, rv), BIND(v, lv / rv).

OurExprEval(v) :- <: ... :- ..., BIND(t, x*y + $e), ... .:>, Eval($e, v).

# OurExprEval = {3}.
OUTPUT('OurExprEval, "OurExprEval", "csv").
#+END_SRC

*** Type hierarchy for Java
#+BEGIN_SRC

ClassImplementsInterface(c, i) :-
		<: class `c implements .., `i, .. { .. } :>,
		ID(`c, c), ID(`i, i).
InterfaceExtendsInterface(i, j) :-
		<: interface `i extends `j { .. } :>,
		ID(`i, i), ID(`j, j).
ClassExtendsClass(c, d) :-
		<: class `c extends `d { .. } :>,
		ID(`c, c), ID(`d, d).
ClassImplementsInterface(c, i), ClassExtendsClass(c, d) :-
		<: class `c extends `d implements .., `i, .. { .. } :>,
		ID(`c, c), ID(`d, d), ID(`i, i).


SuperClass(c, s) :- ClassExtendsClass(c, s).
SuperClass(c, s) :- ClassExtendsClass(c, d), SuperClass(d, s).

SuperInterface(i, s) :- InterfaceExtendsInterface(i, s).
SuperInterface(i, s) :- InterfaceExtendsInterface(i, j), SuperInterface(j, s).

Interface(c, i) :- ClassImplementsInterface(c, i).
Interface(c, i) :- SuperClass(c, d), Interface(d, i).
Interface(c, i) :- Interface(c, j), SuperInterface(j, i).

OUTPUT('Interface, "Interface.csv", "csv").
OUTPUT('SuperClass, "SuperClass.csv", "csv").
OUTPUT('SuperInterface, "SuperInterface.csv", "csv").
#+END_SRC

* License
This repository is covered by a BSD 2-clause license, see [[./LICENSE][LICENSE]].

* Debugging
The following commands are useful when debugging MetaDL:
- Pretty print the desugared program in MetaDL format ~java -jar compiler.jar --pretty-print metadl program.mdl~
- Pretty print the desugared program in Souffle format ~java -jar compiler.jar --pretty-print metadl program.mdl~
- Enable internal debug printouts by setting ~METADL_LOG=debug|time|info~ in the environment.

* Dependencies
** SEP
[[https://git.cs.lth.se/al7330du/sppf-earley-parser][SEP]] is an Earley parser implementation. We use it to parse the patterns.

** JastAdd
[[http://jastadd.org/web/][JastAdd]] is a meta-compilation system that
supports Reference Attribute Grammars (RAGs). It uses the parser
generated from Beaver. In addition it takes an abstract grammar description file as
input. The abstract grammar description is used to generate the classes
that represent the AST.

** ExtendJ
[[https://extendj.org][ExtendJ]] is an extensible Java compiler built using JastAdd.
